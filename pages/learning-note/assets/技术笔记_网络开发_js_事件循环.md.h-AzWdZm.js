import{_ as e,c as a,o as i,a2 as l}from"./chunks/framework.CMEibtfH.js";const m=JSON.parse('{"title":"事件循环","description":"","frontmatter":{},"headers":[],"relativePath":"技术笔记/网络开发/js/事件循环.md","filePath":"技术笔记/网络开发/js/事件循环.md","lastUpdated":1713098747000}'),t={name:"技术笔记/网络开发/js/事件循环.md"},s=l('<h1 id="事件循环" tabindex="-1">事件循环 <a class="header-anchor" href="#事件循环" aria-label="Permalink to &quot;事件循环&quot;">​</a></h1><h2 id="js-的运行机制" tabindex="-1">js 的运行机制 <a class="header-anchor" href="#js-的运行机制" aria-label="Permalink to &quot;js 的运行机制&quot;">​</a></h2><ol><li>所有同步任务都在主线程上顺序执行，称为执行栈。</li><li>主线程之外，还存在任务队列，产生的异步任务会放置到任务队列中。</li><li>执行栈中的所有同步任务执行完毕后，就会读取任务队列，开始依次执行对应的异步任务。</li><li>主线程不断重复第三步直至任务队列为空。这个过程也称为事件循环。</li></ol><h2 id="任务类型" tabindex="-1">任务类型 <a class="header-anchor" href="#任务类型" aria-label="Permalink to &quot;任务类型&quot;">​</a></h2><p>宏观任务包括：</p><ul><li>script 标签内的代码</li><li>setTimeout、setInterval、setImmediate</li><li>I/O</li><li>UI rendering</li></ul><p>微观任务包括：</p><ul><li>process.nextTick</li><li>Promises</li><li>Object.observe</li><li>MutationObserver</li><li>MessageChannel</li></ul><h2 id="异步事件执行顺序" tabindex="-1">异步事件执行顺序 <a class="header-anchor" href="#异步事件执行顺序" aria-label="Permalink to &quot;异步事件执行顺序&quot;">​</a></h2><ol><li>在执行栈为空时，先查看微观任务队列，如果微观队列为空执行第 3 步，不为空执行第 2 步。</li><li>载入微观任务队列的所有任务，执行过程中产生的微观或宏观任务重新放入对应队列中，然后回到第 1 步。</li><li>查看宏观任务队列，如果宏观队列为空程序结束，不为空执行第 4 步。</li><li>载入宏观任务队列的第一个任务，执行过程中产生的微观或宏观任务重新放入对应队列中，然后回到第 1 步。</li></ol>',10),r=[s];function o(n,c,_,d,h,u){return i(),a("div",null,r)}const f=e(t,[["render",o]]);export{m as __pageData,f as default};
