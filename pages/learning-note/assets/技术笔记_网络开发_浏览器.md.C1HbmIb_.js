import{_ as e,c as l,o,a2 as i}from"./chunks/framework.CMEibtfH.js";const p=JSON.parse('{"title":"浏览器相关","description":"","frontmatter":{},"headers":[],"relativePath":"技术笔记/网络开发/浏览器.md","filePath":"技术笔记/网络开发/浏览器.md","lastUpdated":1714313140000}'),t={name:"技术笔记/网络开发/浏览器.md"},a=i('<h1 id="浏览器相关" tabindex="-1">浏览器相关 <a class="header-anchor" href="#浏览器相关" aria-label="Permalink to &quot;浏览器相关&quot;">​</a></h1><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix#css_prefixes" target="_blank" rel="noreferrer">各浏览器特殊属性前缀</a></li></ul><h2 id="请求页面过程" tabindex="-1">请求页面过程 <a class="header-anchor" href="#请求页面过程" aria-label="Permalink to &quot;请求页面过程&quot;">​</a></h2><ol><li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址</li><li>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接</li><li>浏览器发出读取文件（URL 中域名后面部分对应的文件）的 HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器</li><li>服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器</li><li>释放 TCP 连接</li><li>浏览器将该 html 文本并显示内容</li></ol><h2 id="解析页面过程" tabindex="-1">解析页面过程 <a class="header-anchor" href="#解析页面过程" aria-label="Permalink to &quot;解析页面过程&quot;">​</a></h2><ol><li>请求页面并获得返回值后，Web 浏览器创建 Document 对象，开始解析 Web 页面</li></ol><ul><li>解析 HTML 元素和它们的文本内容后添加 Element 对象和 Text 节点到文档中</li><li>这个阶段 <code>document.readyState</code> 属性的值是 <code>loading</code></li></ul><ol start="2"><li>当 HTML 解析器遇到没有 <code>async</code> 和 <code>defer</code> 属性的 script 元素时，它把这些元素添加到文档中，然后执行行内或外部脚本</li></ol><ul><li>这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停</li><li>这样脚本可以用 <code>document.write()</code> 方法来把文本插入到输入流中，解析器恢复时这些文本会成为文档的一部分</li><li>同步脚本经常简单定义函数和注册后面使用的注册事件处理程序，但它们可以遍历和操作文档树，因为在它们执行时已经存在了</li><li>同步脚本可以看到它自己的 script 元素和它们之前的文档内容</li></ul><ol start="3"><li>当解析器遇到设置了 <code>async</code> 属性的 script 元素时，它开始下载脚本文本，并继续解析文档</li></ol><ul><li>脚本会在它下载完成后尽快执行，但是解析器没有停下来等它下载</li><li>异步脚本禁止使用 <code>document.write()</code> 方法，因为此时文档结构已经创建完成，调用该方法会将原来的结构全部覆盖。</li><li>它们可以看到自己的 script 元素和它之前的所有文档元素，并且可能或干脆不可能访问其他的文档内容</li></ul><ol start="4"><li>当文档完成解析，<code>document.readyState</code> 属性变成 <code>interactive</code></li><li>所有有 <code>defer</code> 属性的脚本，会按它们在文档的里的出现顺序执行</li></ol><ul><li>异步脚本可能也会在这个时间执行</li><li>延迟脚本能访问完整的文档树，同样禁止使用 <code>document.write()</code> 方法</li></ul><ol start="6"><li>浏览器在 Document 对象上触发 <code>DOMContentLoaded</code> 事件</li></ol><ul><li>这标志着程序执行从同步脚本执行阶段转换到了异步事件驱动阶段</li><li>这时可能还有异步脚本没有执行完成</li></ul><ol start="7"><li>这时，文档已经完全解析完成，但是浏览器可能还在等待其他内容载入，如图片</li></ol><ul><li>当所有这些内容完成载入时，并且所有异步脚本完成载入和执行，<code>document.readyState</code> 属性改变为 <code>complete</code></li><li>Web 浏览器触发 Window 对象上的 <code>load</code> 事件</li></ul><ol start="8"><li>从此刻起，会调用异步事件，以异步响应用户输入事件、网络事件、计时器过期等</li></ol>',19),d=[a];function c(r,n,s,u,_,h){return o(),l("div",null,d)}const f=e(t,[["render",c]]);export{p as __pageData,f as default};
